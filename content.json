{"meta":{"title":"inagnone","subtitle":null,"description":null,"author":"inagnone","url":"https://inagnone.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-03-29T17:32:18.000Z","updated":"2020-03-30T18:18:03.911Z","comments":true,"path":"categories/index.html","permalink":"https://inagnone.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-29T17:29:41.000Z","updated":"2020-03-30T18:31:12.958Z","comments":true,"path":"tags/index.html","permalink":"https://inagnone.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据仓库集成方案","slug":"数据仓库集成方案","date":"2020-04-15T18:15:13.000Z","updated":"2020-04-15T18:18:48.166Z","comments":true,"path":"2020/04/16/数据仓库集成方案/","link":"","permalink":"https://inagnone.github.io/2020/04/16/数据仓库集成方案/","excerpt":"","text":"源数据提取本地源数据推送将日志采集的原始数据推送到数据平台ods层 ods（Operational Data Store）操作性数据 特点 1、结构源数据保持一致 2、一旦写入不能被修改 通过在数据平台建立数据集成任务，通过配置数据源，设置规则，即可将本地系统中指定表中数据集成到数据平台的ods层中。 dw层数据建模 dw（Data Warehouse）数据仓库，包含所有主题的通用数据集合。 dw层模型一般分为两类，维度表和事实表。维度表描述对象，如项目信息。事实表描述对象行为信息，如单据信息。 特点 1、应用数据都应该来自于dw层 2、只允许增加不允许删除和修改 这一步有两个目的： 1、建立对象模型，如果ods的数据是来自多个系统，将不同系统的相同主题域对象信息进行汇总。 2、按主题生成对象的事实表。（清楚ods中的无效字段，提高信息的颗粒度等）。 dm层数据汇总 dm（Data Mart）数据集市，为了特定的应用目的或应用范围，而从数据仓库中独立出来的一部分数据。 特点 1、dm针对具体应用业务建立 2、dm间不相互依赖 dm中对dw的数据进行汇总，生成具体业务需要的数据 dm层数据回写本地数据库","categories":[],"tags":[]},{"title":"寻找两个有序数组的中位数","slug":"寻找两个有序数组的中位数","date":"2020-04-14T16:18:51.000Z","updated":"2020-04-15T15:32:48.858Z","comments":true,"path":"2020/04/15/寻找两个有序数组的中位数/","link":"","permalink":"https://inagnone.github.io/2020/04/15/寻找两个有序数组的中位数/","excerpt":"","text":"","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"https://inagnone.github.io/categories/leetcode题解/"}],"tags":[]},{"title":"无重复字符的最长子串","slug":"无重复字符的最长子串","date":"2020-04-06T16:15:56.000Z","updated":"2020-04-07T18:07:39.379Z","comments":true,"path":"2020/04/07/无重复字符的最长子串/","link":"","permalink":"https://inagnone.github.io/2020/04/07/无重复字符的最长子串/","excerpt":"leetcode 3 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","text":"leetcode 3 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 暴力解法1、i,j分别作为子串的起始下标和结束下标（0&lt;=i&lt;=j&lt;=s.length()），遍历字符串，得到所有子串 2、判断子串是否不包含重复字符 3、对不包含重读字符的子串记录长度。 123456789101112131415161718192021222324//计算最长不重复子串public int lengthOfLongestSubstring(String s) &#123; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; if(isUnique(s,i,j))&#123; max = Math.max(max,j-i+1); &#125;else&#123; break; &#125; &#125; &#125; return max;&#125;//判断字符串是否包含重复字符public boolean isUnique(String s,int startIndex,int endIndex)&#123; HashSet&lt;Character&gt; set = new HashSet(); for(int i=startIndex;i&lt;=endIndex;i++)&#123; char c = s.charAt(i); if(set.contains(c))return false; set.add(c); &#125; return true;&#125; 暴力的解法提交后会提示超时。 优化如果当前子串含有重复字符，i移动到下一位后，由于只要找到最长的子串，因此无需对每一个以i位开头的子串判断，可直接判断(i,i+max)的子串，即每一次循环，j可以直接从i+max开始 12345678910111213public int lengthOfLongestSubstring(String s) &#123; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i+max;j&lt;s.length();j++)&#123; if(isUnique(s,i,j))&#123; max = Math.max(max,j-i+1); &#125;else&#123; break; &#125; &#125; &#125; return max;&#125; 滑动窗口 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i,j) 向右滑动 1 个元素，则它将变为 [i+1,j+1)（左闭，右开）。 不断扩大j，直到s[j]出现在sij中，此时sij为重复子串。将窗口左边界右移，即将原窗口只最先出现的s[j]及其前面的字符移除窗口，然后继续扩大窗口。窗口出现的最大宽度，即为最长不重复子串长度 1234567891011121314151617181920public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap(); int startIndex = 0; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; if(map.get(s.charAt(i)) == null)&#123; map.put(s.charAt(i),i); max = Math.max(max,(i-startIndex+1)); &#125;else&#123; int showAt = map.get(s.charAt(i)); int ss = startIndex; startIndex = showAt+1; for(int n=ss;n&lt;startIndex;n++)&#123; map.remove(s.charAt(n)); &#125; map.put(s.charAt(i),i); &#125; &#125; return max;&#125;","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"https://inagnone.github.io/categories/leetcode题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://inagnone.github.io/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://inagnone.github.io/tags/滑动窗口/"}]},{"title":"数据库系统原理","slug":"数据库系统原理","date":"2020-04-02T16:26:14.000Z","updated":"2020-04-05T08:46:25.034Z","comments":true,"path":"2020/04/03/数据库系统原理/","link":"","permalink":"https://inagnone.github.io/2020/04/03/数据库系统原理/","excerpt":"","text":"事务ACID特性原子性 Atomicity一致性Consistency数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的 隔离性 Isolation一个事务所做的修改在最终提交之前，对其他事务都是不可见的 持久性一旦事务提交，则其所做的修改将永远保存到数据库中，即使系统崩溃，事务执行结果也不会丢失 ACID之间的关系 只有满足一致性，事务的执行结果才是正确的 在无并发情况下，事务串行，隔离性一定满足，各事务只要满足原子性，一定满足一致性 并发情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性 并发一致性问题丢失修改T1和T2两个事务对同一个数据进行修改，T1先修改，T2后修改，T2的修改覆盖了T1的修改（T1的修改对T2不可见） 读脏数据T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 事务隔离级别未提交读（READ UNCOMMITTED）事务中的修改，即使没有提交，对其它事务也是可见的。 提交读（READ COMMITTED）一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ）保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化（SERIALIZABLE）强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://inagnone.github.io/categories/数据库/"}],"tags":[{"name":"理论学习","slug":"理论学习","permalink":"https://inagnone.github.io/tags/理论学习/"}]},{"title":"mysql技术内幕笔记","slug":"mysql技术内幕笔记","date":"2020-04-01T14:47:55.000Z","updated":"2020-04-01T14:47:55.269Z","comments":true,"path":"2020/04/01/mysql技术内幕笔记/","link":"","permalink":"https://inagnone.github.io/2020/04/01/mysql技术内幕笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hexo+Next主题样式自定义","slug":"Hexo+Next主题个性化","date":"2020-03-29T16:22:05.000Z","updated":"2020-03-30T18:29:22.599Z","comments":true,"path":"2020/03/30/Hexo+Next主题个性化/","link":"","permalink":"https://inagnone.github.io/2020/03/30/Hexo+Next主题个性化/","excerpt":"记录hexo+next下主题自定义样式的修改","text":"记录hexo+next下主题自定义样式的修改 首页文章缩略在文章中插入&lt;!-- more --&gt;,文章在首页中将会被截断，只显示开头到&lt;!-- more --&gt;之间的内容，达到缩略的效果 文章间距文件\\themes\\next\\source\\css\\_schemes\\Mist\\_posts-expanded.styl 1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 文章页样式修改文件theme/next/source/css/_custom/custom.styl 页面添加背景图片1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 图片链接是相对custom.styl文件的相对路径 页面头部和底部栏背景色设置123456.header &#123; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125;.footer &#123; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125; 文章背景色及半透明设置12345.content &#123; border-radius: 10px;#设置文章背景圆角 margin-top: 60px; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125; 文章内单行代码样式1234#posts code &#123; color: 颜色代码;#字体颜色 background-color:颜色代码;#背景颜色&#125; 代码块样式修改主题配置文件更改highlight_theme字段12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 文章页面宽度设置1.main-inner &#123;width: 页面宽度;&#125; 文章添加阴影效果1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 网页顶部和底部文字 顶部文字 theme/next/source/css/_common/components/header/site-meta.styl .brand{}中设置color属性 1234567891011&gt; .brand &#123;&gt; position: relative;&gt; display: inline-block;&gt; padding: 0 40px;&gt; // color: $brand-color;&gt; color: #fff !important;&gt; background: $brand-bg;&gt; border-bottom: none;&gt; &amp;:hover &#123; color: $brand-hover-color; &#125;&gt; &#125;&gt; theme/next/source/css/_common/components/header/menu.styl a{}中设置color属性 1234567891011&gt; a &#123;&gt; display: block;&gt; font-size: 13px;&gt; line-height: inherit;&gt; border-bottom: 1px solid $menu-link-border;&gt; transition-property: border-color;&gt; the-transition();&gt; color: #fff !important;&gt; &amp;:hover &#123; border-bottom-color: $menu-link-hover-border; &#125;&gt; &#125;&gt; 底部字体 1.footer-inner &#123;color: 颜色代码;&#125; 文章字体修改文件theme/next/source/css/_common/scaffolding/base.styl 1234567891011body &#123; position: relative; /* Required by scrollspy */ font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: 颜色代码; background: $body-bg-color; +mobile() &#123; padding-right: 0 !important; &#125; +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; Mist风格侧边栏样式侧边栏位置 文件next/source/js/src/motion.js 把所有PaddingRight更改为paddingLeft（有2处） 12&#123;paddingLeft: SIDEBAR_WIDTH&#125;,NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); 文件next/source/css/_common/components/sidebar/sidebar.styl 将.sidebar{}内的right: 0;改为left: 0; 1234.sidebar &#123; position: fixed; left: 0;&#125; 文件next/source/css/_common/components/sidebar/sidebar-toggle.styl 将.sidebar-toggle{}内的right: $b2t-position-right;改为left: $b2t-position-right; 1234.sidebar-toggle &#123; position: fixed; left: $b2t-position-right;&#125; 文件next/source/css/_common/components/back-to-top.styl 将.back-to-top {}内的right: $b2t-position-right;改为left: $b2t-position-right; 123456.back-to-top &#123; box-sizing: border-box; position: fixed; bottom: $b2t-position-bottom; left: $b2t-position-right;&#125; 作者头像旋转文件\\themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 参考博文 http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html https://segmentfault.com/a/1190000009544924#articleHeader21 http://blog.csdn.net/MasterAnt_D/article/details/56839222#t50 https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","categories":[{"name":"前段","slug":"前段","permalink":"https://inagnone.github.io/categories/前段/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://inagnone.github.io/tags/HEXO/"},{"name":"Next","slug":"Next","permalink":"https://inagnone.github.io/tags/Next/"}]},{"title":"activiti笔记","slug":"activiti","date":"2019-06-16T16:22:05.000Z","updated":"2020-03-30T18:13:45.726Z","comments":true,"path":"2019/06/17/activiti/","link":"","permalink":"https://inagnone.github.io/2019/06/17/activiti/","excerpt":"activiti框架学习笔记","text":"activiti框架学习笔记 数据库设计通用数据表（以ACT_GE_开头）存放一些通用数据 资源表（ACT_GE_BYTEARRAY）用于保存于流程引擎相关的资源，资源会被转换为byte数组保存到这个表中。一般情况下，activiti使用这个表来保存字符串、流程文件的内容和流程图片内容 字段 含义 关联表 ID_ 主键 REV_ 数据版本 NAME_ 资源名称 DEPLOYMENT_ID_ 部署ID ACT_RE_DEPLOYMENT_ID BYTES_ 资源内容 GENERATED_ 是否有activiti自动产生的资源 属性表（ACT_GE_PROPERTY） 字段 含义 关联表 NAME_ 属性名称 VALUE_ 属性值 REV_ 数据版本号 初始化时会自动加入4个属性： historyLevel: next.dbid: schema.history: schema.versino: 流程存储表（以ACT_RE_开头）保存流程定义和部署信息 部署数据表（ACT_RE_DEPLOYMENT）对流程部署这一操作的记录 字段 含义 关联表 ID_ 主键 NAME_ 部署名称 DEPLOYMENT_TIME_ 部署时间 流程定义表（ACT_RE_PROCDEF） 字段 说明 关联表 ID_ 主键 REV_ 数据版本 CATEGORY_ 流程定义分类 NAME_ 流程定义的名称，bpmn的xml文件中process元素的name KEY_ 流程定义的key，bpmn的xml文件中process元素的id VERSION 流程定义的版本，流水号，同名流程文件重复部署，版本号+1 DEPLOYMENT_ID 流程定义的对应的部署数ID ACT_RE_DEPLOYMENT RESOURCE_NAME 流程定义对应资源名称，一般问流程文件相对路径 DGRM_RESOURCE_NAME l流程定义对应的流程图的资源名称 HAS_START_FROM_KEY_ 流程文件是否有开始表单 SUSPENSION_STATE_ 流程定义的状态是激活还是终止，激活时为1，终止时为2。如果流程定义终止，将不能启动流程 运行时数据表（以ACT_RU开头）流程实例（执行流）表（ACT_RU_EXECUTION）流程启动后会产生一个流程实例，同时会产生相应的执行流，如果一个流程实例只有一条执行流，那么该表中只产生一条数据，既表示流程实例也表示执行流 字段 说明 关联表 ID_ 主键 REV_ 数据版本 PROC_INST_ID 流程实例id BUSINESS_KEY_ 业务主键 PARENT_ID 流程实例的id。表示当前执行流数据属于哪一个流程实例 ACT_RU_EXECUTION PROC_DEF_ID 流程定义id ACT_RE_PROCDEF SUPER_EXEC 父执行流id。表示当前流程实例属于哪一个执行流 ACT_RU_EXECUTION ACT_ID 当前执行流行为的id IS_ACTIVE 当前执行流是否活跃 IS_CONCURRENT 执行流是否正在并行 IS_SCOPE 是否在执行流范围内 IS_ENEVT_SCOPE 是否在事件范围内 SUSPENSION_STATE 标识流程的中断状态 CACHED_ENT_STATE 流程实例的缓存 流程任务表（ACT_RU_TASK） 字段 说明 关联表 ID_ 主键 REV_ 数据版本 ECECUTION_ID 任务所处执行流id ACT_RU_EXECUTION PROC_INST_ID 对应流程实例id ACT_RU_EXECUTION PROC_DEF_ID 对应流程定义id ACT_RE_PROCDEF NAME_ 任务名称 PARENT_TASK_ID 父任务id ACT_RU_TASK DESCRIPTINO 任务描述 TASK_DEF_KEY 任务定义id，bpmn的xml文件中任务的id OWNER 任务拥有人 ASSIGNEE 任务指派人 DELEGATINO 任务委托状态（等待和已解决） PRIORITY 任务优先级 CREATE_TIME 任务创建时间 DUE_DATE 任务预定日期 流程参数表（ACT_RU_VARIABLE）流程参数类型: 流程实例参数 执行流参数 任务参数 字段 说明 关联表 ID 主键 REV_ 数据版本 TYPE 参数类型，类型有activiti提供 NAME 参数名称 EXECUTION_ID 参数对应执行流id ACT_RU_EXECUTION PROC_INST_ID 参数对应流程实例id ACT_RU_EXECUTION TASK_ID 参数对应任务id ACT_RU_TASK BYTEARRAY_ID 引用资源作为参数值的资源id ACT_GE_BYTEARRAY DOUBLE LONG TEXT TEXT2 历史数据表（以ACT_HI开头）流程实例表 （ACT_HI_PROCINST） 字段 说明 关联表 START_ACT_ID 流程开始的活动的id（开始事件的id） END_ACT_ID 流程结束的活动的id（结束事件的id） DELETE_REASON 流程实例删除原因，如果流程正常结束，该字段为completed 流程明细表（ACT_HI_DETAIL）历史任务表（ACT_HI_TASK）与运行时任务表相似 历史行为表（ACT_HI_ACTINST）记录每一个流程活动的实例，一个流程活动记为一条记录（包括开始事件，结束事件） 字段 说明 关联表 ID 主键 PROC_DEF_ID 流程定义id ACT_RE_PROCDEF PROC_INST_ID 流程实例id EXECUTION_ID 执行流id ACT_ID 流程活动的id（bpmn的xml文件中活动的id） ACT_NAME 流程活动的名称（bpmn的xml文件中活动的name） ACT_TYPE 活动类型 ASSIGNEE 活动指派人 START_TINE 开始时间 END_TIME 结束事件 DURATION 活动持续时间","categories":[{"name":"java","slug":"java","permalink":"https://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"oracle虚拟机规范翻译--java虚拟机结构","slug":"oracle虚拟机规范翻译-java虚拟机结构","date":"2019-05-19T12:48:54.000Z","updated":"2020-03-30T18:14:49.455Z","comments":true,"path":"2019/05/19/oracle虚拟机规范翻译-java虚拟机结构/","link":"","permalink":"https://inagnone.github.io/2019/05/19/oracle虚拟机规范翻译-java虚拟机结构/","excerpt":"oracle虚拟机规范","text":"oracle虚拟机规范 class 文件格式class文件是用来存储经编译器编译过的，与硬件和操作系统独立的二进制代码。class文件精确地定义了一个类或者接口，包括其字节顺序等这些在指定平台被认为是理所当然的细节。 数据类型类似java编程语言，java虚拟机在两种类型上运行：基本类型和引用类型。因此这两种类型的值可以被存储在变量中，作为参数传递，被方法返回或者执行运算。 java虚拟机希望几乎所有的类型检查都在运行之前，有编译器负责而不需要java虚拟机来进行。基本类型的值在运行时不需要被标记或者其他检查来确定它的实际数据类型，也不需要和引用类型的值区分开。取而代之，java","categories":[{"name":"java","slug":"java","permalink":"https://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"类加载器","slug":"类加载器","date":"2019-05-16T16:48:11.000Z","updated":"2020-03-30T18:15:17.378Z","comments":true,"path":"2019/05/17/类加载器/","link":"","permalink":"https://inagnone.github.io/2019/05/17/类加载器/","excerpt":"类加载器学习笔记","text":"类加载器学习笔记 java虚拟机使用类的步奏 java源程序（.java文件）经过编译器编译之后被转换成java字节码文件（.class文件） 类加载器负责读取java字节码文件，并构造出java.lang.Class的一个实例对象。 Class的实例对象调用newInstance()方法创造出该类的一个对象 类加载器的类型 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。 每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。 java虚拟机对类的比较Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 类加载器的代理模式类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。","categories":[{"name":"java","slug":"java","permalink":"https://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"分布式框架","slug":"分布式框架","date":"2019-05-02T08:49:22.000Z","updated":"2020-03-30T18:15:12.690Z","comments":true,"path":"2019/05/02/分布式框架/","link":"","permalink":"https://inagnone.github.io/2019/05/02/分布式框架/","excerpt":"分布式框架","text":"分布式框架 HSF ——High Speed Framework 服务提供者 服务调用者 地址服务器 给服务提供者和服务调用者提供部署环境中所有配置服务器和Diamond服务器的服务器列表信息 配置服务器 记录环境内所有服务发布和服务订阅，并将服务相关信息推送到服务节点上。 与所有服务提供者和调用者都是长连接，采用心跳的方式监控服务运行节点的状况 Diamond服务器 通用配置管理服务器，给应用提供统一的配置设置和推送服务 工作原理 服务节点对配置服务器列表的获取。 服务注册发布 服务提供者把自身信息发送到配置服务器 服务的订阅 服务调用者发送调用的服务相关信息到配置服务器，配置服务器返回对应服务的ip和端口等信息 服务规则推送 Diamond服务器对指定服务提供者或调用者推送规则 服务交互","categories":[{"name":"架构","slug":"架构","permalink":"https://inagnone.github.io/categories/架构/"}],"tags":[]},{"title":"java虚拟机结构(一)","slug":"java虚拟机结构-一","date":"2019-04-24T16:00:19.000Z","updated":"2020-03-30T18:14:13.828Z","comments":true,"path":"2019/04/25/java虚拟机结构-一/","link":"","permalink":"https://inagnone.github.io/2019/04/25/java虚拟机结构-一/","excerpt":"java虚拟机学习笔记","text":"java虚拟机学习笔记 Class文件精确定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节上的惯例。 数据类型java虚拟机可以操作的数据类型分给两类： 原始类型 数值类型 整数类型 byte类型：8位有符号 short类型：16位有符号 int类型：32位有符号 long类型：64位有符号 char类型：16位无符号 浮点类型 float类型：32位单精度浮点数 double类型：64位双精度浮点数 boolean类型​ 布尔值true和false，默认false returnAddress类型指向某个操作码的指针，操作码与java虚拟机指令相对应 数据类型 类类型指向动态创建的类实例 数组类型指向动态创建的数组实例 接口类型指向实现了某个接口的类实例 运行时数据区pc寄存器每一个线程都有自己的pc寄存器，且任意时刻都只会各自执行一个方法。如果当前方法时native^native,pc寄存器保存java虚拟机正在执行的字节码指令的地址，如果不是native，pc寄存器保存undefined java虚拟机栈每一个线程都有自己私有的java虚拟机栈，这个栈与线程同时创建，用于存储栈帧 栈异常 stackOverflowError：线程请求分配的栈容量超过了虚拟机允许的最大容量 OutOfmemoryError：扩展栈或者创建一个新线程对应的新栈时，没有足够的内存 栈帧用来存储数据和部分分派结果的数据结构，同时也是用来处理动态链接，方法返回值和异常分派 随方法调用而创建，随方法结束而销毁 栈帧的存储空间由创建它的线程分配在java虚拟机中 每一个栈帧都有自己的本地变量表（局部变量表），操作数栈和指向当前方法所属的类的运行时常量池的引用、 局部变量表 一个局部表量表可以保存一个类型为boolean、byte、char、short、int、float、reference、returnAddress的数据 两个连续的局部变量可以保存一个类型为long或double的数据 局部变量通过索引来进行访问 当调用方法时，参数依次传递到从0开始的连续位置，当调用实例方法时，第0个变量一定是存储该实例方法所在对象的引用(即this关键字) 操作数栈 动态链接 每一个栈帧内部都有一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。在class文件里，一个方法调用其他方法，或者访问成员变量，则需要通过符号引用，动态链接的作用就是就是将这些符号引用所表示的方法转换为对实际方法的直接引用 java堆提供各线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域 堆在虚拟机启动时被创建，存储被gc管理的各种对象 方法区提供各个线程共享的运行时内存区域。 存储一个类的结构信息(运行时常量池，字段，方法数据，构造函数，普通方法的字节码内容) 运行时常量池是class文件中每一个类或者接口的常量池表的运行时表示形式 每一个运行时常量池都在java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池 本地方法栈用来支持native方法执行的栈。(如果虚拟机不支持native方法，可以不提供本地方法栈) 本地方法栈在线程创建的时候按线程分配。","categories":[{"name":"java","slug":"java","permalink":"https://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"查询当前数据库中的事务和锁信息","slug":"Mysql事务锁信息","date":"2019-04-18T17:09:47.000Z","updated":"2020-03-30T18:14:38.414Z","comments":true,"path":"2019/04/19/Mysql事务锁信息/","link":"","permalink":"https://inagnone.github.io/2019/04/19/Mysql事务锁信息/","excerpt":"mysql锁查询字段说明","text":"mysql锁查询字段说明 查询当前数据库中的事务和锁信息information_schema.innodb_trx当前运行的所有事务 Field Remark trx_id 事务ID trx_state 事务状态： trx_started 事务开始时间； trx_requested_lock_id innodb_locks.lock_id trx_wait_started 事务开始等待的时间 trx_weight bigint(21) # trx_mysql_thread_id 事务线程ID trx_query 具体SQL语句 trx_operation_state 事务当前操作状态 trx_tables_in_use 事务中有多少个表被使用 trx_tables_locked 事务拥有多少个锁 trx_lock_structs # trx_lock_memory_bytes 事务锁住的内存大小（B） trx_rows_locked 事务锁住的行数 trx_rows_modified 事务更改的行数 trx_concurrency_tickets 事务并发票数 trx_isolation_level 事务隔离级别 trx_unique_checks 是否唯一性检查 trx_foreign_key_checks 是否外键检查 trx_last_foreign_key_error 最后的外键错误 trx_adaptive_hash_latched # trx_adaptive_hash_timeout # information_schema.innodb_locks当前出现的锁 Field Remark lock_id 锁ID lock_trx_id 拥有锁的事务ID lock_mode 锁模式 lock_type 锁类型 lock_table 被锁的表 lock_index 被锁的索引 lock_space 被锁的表空间号 lock_page 被锁的页号 lock_rec 被锁的记录号 lock_data 被锁的数据 innodb_lock_waits.innodb_lock_waits锁等待的对应关系 Field Remark requesting_trx_id 请求锁的事务ID requested_lock_id 请求锁的锁ID blocking_trx_id 当前拥有锁的事务ID blocking_lock_id 当前拥有锁的锁ID show full processlist查询当前数据库中运行的进程信息（相当于正在执行的每一条sql语句的状态信息） Field Remark id 一个标识 user 显示当前用户，如果不是root，这 个命令就只显示你权限范围内的sql语句。 host 显示这个语句是从哪个ip的哪个端口上发出的 db 显示 这个进程目前连接的数据库。 command 显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接 （connect）。 time 此这个状态持续的时间，单位是秒。 state 显示使用当前连接的sql语句的状态，只是语句执行中的某一个状态，一个sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成 info 显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。 state列 Field Remark Checking table 正在检查数据表（这是自动的）。 Closing tables 正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。 Connect Out 复制从服务器正在连接主服务器。 Copying to tmp table on disk 由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。 Creating tmp table 正在创建临时表以存放部分查询结果。 deleting from main table 服务器正在执行多表删除中的第一部分，刚删除第一个表。 deleting from reference tables 服务器正在执行多表删除中的第二部分，正在删除其他表的记录。 Flushing tables 正在执行 FLUSH TABLES，等待其他线程关闭数据表。 Killed 发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志 位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。 Locked 被其他查询锁住了。 Sending data 正在处理 SELECT 查询的记录，同时正在把结果发送给客户端。 Sorting for group 正在为 GROUP BY 做排序。 Sorting for order 正在为 ORDER BY 做排序。 Opening tables 这个过程应该会很快，除非受到其他因素的干扰。例如，在执 ALTER TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。 正尝试打开一个表。 Removing duplicates 正在执行一个 SELECT DISTINCT 方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。 Reopen table 获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。 Repair by sorting 修复指令正在排序以创建索引。 Repair with keycache 修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些。 Searching rows for update 正在讲符合条件的记录找出来以备更新。它必须在 UPDATE 要修改相关的记录之前就完成了。 Sleeping 正在等待客户端发送新请求. System lock 正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加 –skip-external-locking参数来禁止外部系统锁。 Upgrading lock INSERT DELAYED 正在尝试取得一个锁表以插入新记录。 Updating 正在搜索匹配的记录，并且修改它们。 User Lock 正在等待 GET_LOCK()。 Waiting for tables 该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种 情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, 或 OPTIMIZE TABLE。 waiting for handler insert INSERT DELAYED 已经处理完了所有待处理的插入操作，正在等待新的请求。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://inagnone.github.io/categories/数据库/"}],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2019-04-18T17:09:47.000Z","updated":"2020-03-30T18:14:30.093Z","comments":true,"path":"2019/04/19/markdown语法/","link":"","permalink":"https://inagnone.github.io/2019/04/19/markdown语法/","excerpt":"markdown语法学习笔记","text":"markdown语法学习笔记 标题 # This is an H1 ## This is an H2 r 区块引用 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 列表 red green blue 1234567891011* red* green* blue或+ red+ green+ blue、或- red- green- blue red green blue 1231. red2. green3. blue 代码区块分隔线 12345****或- - -或--------------------------- 链接行内式链接这是一个百度 1这是一个[百度](https://www.baidu.com) 参考式链接这是一个百度 12这是一个[百度][1][1]: https://www.baidu.com \"百度地址\" 强调single asterisks single underscores double asterisks double underscores 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 代码行内代码use the print() function 1Use the `printf()` function. 代码区段There is a literal backtick (`) here. 1There is a literal backtick (`) here. 12``There is a literal backtick (`) here.``​```There is a literal backtick (`) here. 1234567891011# 图片![Alt text](https://k.zol-img.com.cn/sjbbs/7692/a7691501_s.jpg&quot;图片&quot;)``` ![Alt text](/path/to/img.jpg &quot;Optional title&quot;)Alt text:图片替代文字“path/to/img.jpg”:图片地址Optional title:图片title ==asd== 删除文本此部分已被删除 1~~~此部分已被删除~~~ 选择框 计划任务 完成任务 12- [x] 计划任务- [] 完成任务 表格 项目 Value 电脑 $1600 手机 $12 导管 $1 12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 设定内容格式使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 123| 第一列 | 第二列 | 第三列 ||:-----------:| -------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 注脚一个具有注脚的文本。^2 123一个具有注脚的文本。[^2][^2]: 注脚的解释 流程图参考","categories":[{"name":"语法","slug":"语法","permalink":"https://inagnone.github.io/categories/语法/"}],"tags":[]},{"title":"位运算--两束之和","slug":"位运算——两数相加","date":"2019-04-18T17:09:47.000Z","updated":"2020-04-06T17:24:31.450Z","comments":true,"path":"2019/04/19/位运算——两数相加/","link":"","permalink":"https://inagnone.github.io/2019/04/19/位运算——两数相加/","excerpt":"leetcode 371题解","text":"leetcode 371题解 371. 两整数之和 两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 例子：11+5 其二进制形式为11: 1011, 5: 0101 计算步骤：1、与运算得出哪些位需要进位11&amp;5 –&gt; 00012、异或运算得到两数二进制各位上分别相加的结果11^5 –&gt; 11103、将需要的进位加到第2步的结果0001表示最后一位需要进位，左移1为0001&lt;&lt;1–》0010此时运算结果为0010与1110的和，重复第一步 123456789public int getSum(int a, int b) &#123; int carry = a &amp; b; int sum = a ^ b; while(carry != 0)&#123; carry = carry &lt;&lt; 1; return getSum(sum,carry); &#125; return sum; &#125; 参考文章：blog.csdn.net/qq508618087/article/details/51789576","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"https://inagnone.github.io/categories/leetcode题解/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-18T16:57:04.981Z","updated":"2020-03-30T18:14:04.748Z","comments":true,"path":"2019/04/19/hello-world/","link":"","permalink":"https://inagnone.github.io/2019/04/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前段","slug":"前段","permalink":"https://inagnone.github.io/categories/前段/"}],"tags":[]}]}