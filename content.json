{"meta":{"title":"inagnone","subtitle":null,"description":null,"author":"inagnone","url":"http://inagnone.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-03-29T17:32:18.000Z","updated":"2020-12-23T16:31:11.914Z","comments":true,"path":"categories/index.html","permalink":"http://inagnone.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-29T17:29:41.000Z","updated":"2020-12-23T16:31:11.922Z","comments":true,"path":"tags/index.html","permalink":"http://inagnone.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-12-23T16:31:11.780Z","updated":"2020-12-23T16:31:11.780Z","comments":true,"path":"2020/12/24/hello-world/","link":"","permalink":"http://inagnone.github.io/2020/12/24/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前段","slug":"前段","permalink":"http://inagnone.github.io/categories/前段/"}],"tags":[]},{"title":"微服务","slug":"微服务","date":"2020-11-24T11:07:17.000Z","updated":"2020-12-23T16:31:11.894Z","comments":true,"path":"2020/11/24/微服务/","link":"","permalink":"http://inagnone.github.io/2020/11/24/微服务/","excerpt":"","text":"服务注册与发现Eureka注册中心申明为eureka服务端 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 配置信息 1234567891011121314151617181920212223242526272829server: port: 7001eureka: instance: #应用实例主机名 hostname: eureka1 client: #是否从Eureka获取注册信息,默认是true,一般server端不需要 fetch-registry: false #是否向注册中心注册自己 register-with-eureka: false #eurekaServer查询服务和注册服务的地址,当server是集群是，server之间互相配置 service-url: defaultZone: http://eureka2:7002/eureka/spring: profiles: 7001---server: port: 7002eureka: instance: hostname: eureka2 client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://eureka1:7001/eureka/spring: profiles: 7002 服务提供方@EnableEurekaClient注解申明Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class PaymentApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentApplication.class); &#125;&#125; 配置信息 1234567891011spring: application: #微服务名称 name: cloud-payment-serviceeureka: client: register-with-eureka: true #是否从eurekaServer抓取已有的注册信息 fetch-registry: true service-url: defaultZone: http://eureka1:7001/eureka/,http://eureka2:7002/eureka/ 服务调用方应用配置与服务提供方一致 服务调用 1234567private String paymentServiceName = \"CLOUD-PAYMENT-SERVICE\";@GetMapping(\"order\")@ResponseBodypublic String createPayment()&#123; return restTemplate.postForObject(\"http://\" + paymentServiceName + \"/payment/save\", null, String.class);&#125; 负载均衡Ribbon与nginx的区别 ngnix是服务端 的负载均衡，ribbon是客户端的负载均衡 工作流程 选择注册中心 从注册中心获取目标服务地址 根据策略从获取的地址中选择一个调用服务 启动负载均衡12345@Bean@LoadBalancedpublic RestTemplate getRestTemplate()&#123; return new RestTemplate();&#125; 通过注册的restTemplate的进行服务调用时，默认使用轮询算法 替换策略服务调用openFeign依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 使用定义接口12345678910@Service@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")public interface OrderService &#123; @PostMapping(\"/payment/save\") public String save(); @GetMapping(\"/payment/timeOut\") public String timeOut();&#125; @FeignClient(value = “CLOUD-PAYMENT-SERVICE”)：将接口与CLOUD-PAYMENT_SERVICE服务绑定 调用服务123public String callPaymentTimeOut()&#123; return orderService.timeOut();&#125;","categories":[],"tags":[]},{"title":"kafka","slug":"kafka","date":"2020-11-19T07:46:37.000Z","updated":"2020-12-23T16:31:11.781Z","comments":true,"path":"2020/11/19/kafka/","link":"","permalink":"http://inagnone.github.io/2020/11/19/kafka/","excerpt":"","text":"Topic主题kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题，而消费这负责订阅主题并进行消费","categories":[],"tags":[]},{"title":"docker","slug":"docker","date":"2020-11-19T06:08:56.000Z","updated":"2020-12-23T16:31:11.779Z","comments":true,"path":"2020/11/19/docker/","link":"","permalink":"http://inagnone.github.io/2020/11/19/docker/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HashMap源码解析","slug":"HashMap源码解析","date":"2020-05-18T15:45:42.000Z","updated":"2020-12-23T16:31:11.776Z","comments":true,"path":"2020/05/18/HashMap源码解析/","link":"","permalink":"http://inagnone.github.io/2020/05/18/HashMap源码解析/","excerpt":"","text":"常量介绍default_initial_capacity:默认初始容量，1&lt;&lt;4,即16。 根据上图可以看出，hashMap由最上层是一个数组，数组中每一个元素是一个链表或者一棵红黑树。链表的每一个节点或者红黑树的节点才是我们put进去的元素，即hashmap的容量=所有被占用的数组位下的链表的和 default_load_factory:默认加载因子。当哈希表条目数量超过加载因子与容量的乘积，哈希表容量扩大为原来的2倍，且内部条目被重新映射。加载因子过大会导致链表过长，查询时间成本增加；过小会导致频繁扩容。默认是0.75 threshold：扩容阀值。值是加载因子与容量的乘积。 TREEIFY_THRESHOLD:树化阀值。数组元素最初是构建成链表的结构，当一个链表的长度超过了TREEIFY_THRESHOLD后，hashmap会将这个链表转化为一个红黑树，默认是8 UNTREEIFY_THRESHOLD:非树化结构，在hashmap一个已经转化的红黑树上，如果因为remove等操作导致树的节点数量小于UNTREEIFY_THRESHOLD，那么这个红黑树将会被退化为链表。默认是6. MIN_TREEIFY_CAPACITY：hashmap树化的最小容量。hashmap将链表转化为红黑树，还需要满足容量大于MIN_TREEIFY_CAPACITY。默认是64。 数据结构interface Entry&lt;K,V&gt;数组元素Node都是此接口的实现类，从上图可以看出，hashMap实际上是个Node的数组，数组的每一个元素要么是个链表，要么是个树，因此node也可以理解为进入数组元素中的链表或者树的入口 Node&lt;K,V&gt;[] tablehashmap主要是通过维护这样一个Node的数组来实现map接口的各个方法。 table只有在第一次使用时才会被初始化，大小永远是2次幂。 Node&lt;K,V&gt; implements Map.Entry&lt;K，V&gt;hashmap最初构造的数组元素结构 1234567static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; ……&#125; TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;12345678static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; ……&#125; LinkedHashMap.Entry&lt;K,V&gt; extends Map.Entry&lt;K，V&gt; 构造方法12345678910111213141516public HashMap(int initialCapacity, float loadFactor) &#123; // 指定期望初始容量小于0将会抛出非法参数异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // 期望初始容量不可以大于最大值 2^30 实际上我们也不会用到这么大的容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 加载因子必须大于0 不能为无穷大 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor;//初始化全局加载因子变量 this.threshold = tableSizeFor(initialCapacity);//根据初始容量计算计算扩容阈值&#125; tableSizeFor方法的作用是将用户输入的初始大小变为2次幂 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 要将cap变为2次幂，从二进制来看，只需把最高位的1底下的所有位都变为1，然后再加1，即可得到大于cap且与cap最接近的2次幂。 例如当cap=18时，二进制是10010。那么我们的目标是得到100000，即32。 因为cap&gt;0,即cap的二进制必定存在一位是1，我们只需要找到最左边的1。 右移1位，10010|01001 = 11011 此时原最高位的1及其右边一位也变为了1 右移2位，11011|00110=11111 此时原最高位1及其右边三位都变为1，如此即可将原来出现的最高位1右边的数字都变为1. 最后再加上1=100000,即为2次幂. 最初的cap-1，避免了当cap原来就是2次幂，导致最后根据上面的方法算出2*cap。即当cap是2次幂时，把最高位1右移一位。 hash方法1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 1、为什么要无符号右移16位 将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以将高低位二进制特征混合起来 混合的目的是后续做与运算计算槽位的时候，避免丢失高位区特征。 2、使用异或运算的原因 异或运算能更好的保留各部分的特征 采用&amp;运算计算出来的值会向0靠拢 采用|运算计算出来的值会向1靠拢 将计算的hash值映射到数组1int index = (n - 1) &amp; root.hash n是table数组的大小 1、为什么table数组的大小要是2次幂 % 2^n 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&gt;&gt;(**当 b = 2^n 时，a % b = a &amp; (b - 1)** )&gt;&gt;计算哈希值的在数组下标的映射，可以理解为对table数组长度取模，而只有当长度是2次幂，才能是上面的等式成立。应为与运算的效率远高于取模运算，所以table数组的长度就需要保持2次幂## 常见的哈希算法### 直接定址法直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)=ak+b）。### 数字分析法提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率） ### 分段叠加法按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。### 平方取中法如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 ### 伪随机数法选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。 ### 除留余数法用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)=k%p, p&lt;=m; p一般取m或素数）。## 常用解决hash冲突方法### 链地址法将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。### 开放定址法即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。### 再哈希法即发生冲突时，由其他的函数再计算一次哈希值。### 建立公共溢出区将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。# resize()初始化或者将table数组扩容2倍。```javafinal Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; /*********************计算新table的容量******************************************/ if (oldCap &gt; 0) &#123; // 如果当前容量大于允许的最大容量，将容量阀值设置成最大，直接返回原table，不在进行扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; /********************将旧table的元素转移到新table***************************/ @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 方法分两部分功能， 1、计算新的容量 2、将原table的元素一致扩充后的table 将原table的元素移动到扩充后的table红黑树的移动链表的移动对原链表上的元素进行分组 (e.hash &amp; oldCap) == 0的元素分为一组，组成由loHead和loTail指向头尾节点的新链表，放原位置 其他元素分为一组，组成由hiHead和hiTail指向头尾节点的新链表，放原位置+oldCap 该分组方法与重新计算每个元素在对新table长度取模的方法等价。 (e.hash &amp; oldCap) == 0因为oldCap是2次幂，即此时1处在扩容位上，与hash值此位的值做与运算，0位置不变，1位置翻倍 线程不安全原因","categories":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://inagnone.github.io/categories/源码阅读/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"http://inagnone.github.io/tags/Collection/"}]},{"title":"二叉树","slug":"二叉树","date":"2020-05-12T16:33:44.000Z","updated":"2020-12-23T16:31:11.872Z","comments":true,"path":"2020/05/13/二叉树/","link":"","permalink":"http://inagnone.github.io/2020/05/13/二叉树/","excerpt":"","text":"二叉树节点的度结点拥有的子树数目称为结点的度。 节点层次从根开始定义起，根为第一层，根的孩子为第二层，以此类推 数的深度树中结点的最大层次数称为树的深度或高度。所示树的深度为4。 性质1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1） 2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1） 3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。 4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。 5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性： (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; (2) 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点； (3) 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://inagnone.github.io/tags/数据结构/"}]},{"title":"数据仓库集成方案","slug":"数据仓库集成方案","date":"2020-04-15T18:15:13.000Z","updated":"2020-12-23T16:31:11.909Z","comments":true,"path":"2020/04/16/数据仓库集成方案/","link":"","permalink":"http://inagnone.github.io/2020/04/16/数据仓库集成方案/","excerpt":"","text":"源数据提取本地源数据推送将日志采集的原始数据推送到数据平台ods层 ods（Operational Data Store）操作性数据 特点 1、结构源数据保持一致 2、一旦写入不能被修改 通过在数据平台建立数据集成任务，通过配置数据源，设置规则，即可将本地系统中指定表中数据集成到数据平台的ods层中。 dw层数据建模 dw（Data Warehouse）数据仓库，包含所有主题的通用数据集合。 dw层模型一般分为两类，维度表和事实表。维度表描述对象，如项目信息。事实表描述对象行为信息，如单据信息。 特点 1、应用数据都应该来自于dw层 2、只允许增加不允许删除和修改 这一步有两个目的： 1、建立对象模型，如果ods的数据是来自多个系统，将不同系统的相同主题域对象信息进行汇总。 2、按主题生成对象的事实表。（清楚ods中的无效字段，提高信息的颗粒度等）。 dm层数据汇总 dm（Data Mart）数据集市，为了特定的应用目的或应用范围，而从数据仓库中独立出来的一部分数据。 特点 1、dm针对具体应用业务建立 2、dm间不相互依赖 dm中对dw的数据进行汇总，生成具体业务需要的数据 dm层数据回写本地数据库","categories":[],"tags":[]},{"title":"寻找两个有序数组的中位数","slug":"寻找两个有序数组的中位数","date":"2020-04-14T16:18:51.000Z","updated":"2020-12-23T16:31:11.894Z","comments":true,"path":"2020/04/15/寻找两个有序数组的中位数/","link":"","permalink":"http://inagnone.github.io/2020/04/15/寻找两个有序数组的中位数/","excerpt":"","text":"给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 暴力解法将两个数组合并，找到中位数 改进1数组确定，中位数的位置可以确定。数组长度是n，当数组是奇数，中位数=array[n/2]。当长度是偶数，中位数=array[n/2+1]。所以无需真正把两个数组合并。 12345678910111213141516171819202122232425262728293031class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int sum = nums1.length+nums2.length; int index1= 0,index2 = 0; int index = 0; int v1=0,v2= 0; while(index &lt;= sum/2)&#123; v1 = v2; if(index1 &lt; nums1.length)&#123; if( index2 &gt;= nums2.length || nums1[index1] &lt; nums2[index2])&#123; v2 = nums1[index1]; index1++; &#125;else&#123; v2 = nums2[index2]; index2++; &#125; &#125;else&#123; v2 = nums2[index2]; index2++; &#125; index++; &#125; if(sum%2 == 1)&#123; return v2; &#125;else&#123; return (v1+v2)/(2+0.0); &#125; &#125;&#125;","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"http://inagnone.github.io/categories/leetcode题解/"}],"tags":[]},{"title":"无重复字符的最长子串","slug":"无重复字符的最长子串","date":"2020-04-06T16:15:56.000Z","updated":"2020-12-23T16:31:11.913Z","comments":true,"path":"2020/04/07/无重复字符的最长子串/","link":"","permalink":"http://inagnone.github.io/2020/04/07/无重复字符的最长子串/","excerpt":"leetcode 3 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","text":"leetcode 3 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 暴力解法1、i,j分别作为子串的起始下标和结束下标（0&lt;=i&lt;=j&lt;=s.length()），遍历字符串，得到所有子串 2、判断子串是否不包含重复字符 3、对不包含重读字符的子串记录长度。 123456789101112131415161718192021222324//计算最长不重复子串public int lengthOfLongestSubstring(String s) &#123; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; if(isUnique(s,i,j))&#123; max = Math.max(max,j-i+1); &#125;else&#123; break; &#125; &#125; &#125; return max;&#125;//判断字符串是否包含重复字符public boolean isUnique(String s,int startIndex,int endIndex)&#123; HashSet&lt;Character&gt; set = new HashSet(); for(int i=startIndex;i&lt;=endIndex;i++)&#123; char c = s.charAt(i); if(set.contains(c))return false; set.add(c); &#125; return true;&#125; 暴力的解法提交后会提示超时。 优化如果当前子串含有重复字符，i移动到下一位后，由于只要找到最长的子串，因此无需对每一个以i位开头的子串判断，可直接判断(i,i+max)的子串，即每一次循环，j可以直接从i+max开始 12345678910111213public int lengthOfLongestSubstring(String s) &#123; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i+max;j&lt;s.length();j++)&#123; if(isUnique(s,i,j))&#123; max = Math.max(max,j-i+1); &#125;else&#123; break; &#125; &#125; &#125; return max;&#125; 滑动窗口 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i,j) 向右滑动 1 个元素，则它将变为 [i+1,j+1)（左闭，右开）。 不断扩大j，直到s[j]出现在sij中，此时sij为重复子串。将窗口左边界右移，即将原窗口只最先出现的s[j]及其前面的字符移除窗口，然后继续扩大窗口。窗口出现的最大宽度，即为最长不重复子串长度 1234567891011121314151617181920public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap(); int startIndex = 0; int max = 0; for(int i=0;i&lt;s.length();i++)&#123; if(map.get(s.charAt(i)) == null)&#123; map.put(s.charAt(i),i); max = Math.max(max,(i-startIndex+1)); &#125;else&#123; int showAt = map.get(s.charAt(i)); int ss = startIndex; startIndex = showAt+1; for(int n=ss;n&lt;startIndex;n++)&#123; map.remove(s.charAt(n)); &#125; map.put(s.charAt(i),i); &#125; &#125; return max;&#125;","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"http://inagnone.github.io/categories/leetcode题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://inagnone.github.io/tags/字符串/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://inagnone.github.io/tags/滑动窗口/"}]},{"title":"数据库系统原理","slug":"数据库系统原理","date":"2020-04-02T16:26:14.000Z","updated":"2020-12-23T16:31:11.912Z","comments":true,"path":"2020/04/03/数据库系统原理/","link":"","permalink":"http://inagnone.github.io/2020/04/03/数据库系统原理/","excerpt":"","text":"事务ACID特性原子性 Atomicity一致性Consistency数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的 隔离性 Isolation一个事务所做的修改在最终提交之前，对其他事务都是不可见的 持久性一旦事务提交，则其所做的修改将永远保存到数据库中，即使系统崩溃，事务执行结果也不会丢失 ACID之间的关系 只有满足一致性，事务的执行结果才是正确的 在无并发情况下，事务串行，隔离性一定满足，各事务只要满足原子性，一定满足一致性 并发情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性 并发一致性问题丢失修改T1和T2两个事务对同一个数据进行修改，T1先修改，T2后修改，T2的修改覆盖了T1的修改（T1的修改对T2不可见） 读脏数据T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。 不可重复读T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻影读T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。 事务隔离级别未提交读（READ UNCOMMITTED）事务中的修改，即使没有提交，对其它事务也是可见的。 提交读（READ COMMITTED）一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 可重复读（REPEATABLE READ）保证在同一个事务中多次读取同一数据的结果是一样的。 可串行化（SERIALIZABLE）强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://inagnone.github.io/categories/数据库/"}],"tags":[{"name":"理论学习","slug":"理论学习","permalink":"http://inagnone.github.io/tags/理论学习/"}]},{"title":"mysql技术内幕笔记","slug":"mysql技术内幕笔记","date":"2020-04-01T14:47:55.000Z","updated":"2020-12-23T16:31:11.793Z","comments":true,"path":"2020/04/01/mysql技术内幕笔记/","link":"","permalink":"http://inagnone.github.io/2020/04/01/mysql技术内幕笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hexo+Next主题样式自定义","slug":"Hexo+Next主题个性化","date":"2020-03-29T16:22:05.000Z","updated":"2020-12-23T16:31:11.777Z","comments":true,"path":"2020/03/30/Hexo+Next主题个性化/","link":"","permalink":"http://inagnone.github.io/2020/03/30/Hexo+Next主题个性化/","excerpt":"记录hexo+next下主题自定义样式的修改","text":"记录hexo+next下主题自定义样式的修改 首页文章缩略在文章中插入&lt;!-- more --&gt;,文章在首页中将会被截断，只显示开头到&lt;!-- more --&gt;之间的内容，达到缩略的效果 文章间距文件\\themes\\next\\source\\css\\_schemes\\Mist\\_posts-expanded.styl 1234.posts-expand .post &#123; margin-top: 30px; margin-bottom: 30px;&#125; 文章页样式修改文件theme/next/source/css/_custom/custom.styl 页面添加背景图片1234567body&#123; background:url(图片链接); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 图片链接是相对custom.styl文件的相对路径 页面头部和底部栏背景色设置123456.header &#123; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125;.footer &#123; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125; 文章背景色及半透明设置12345.content &#123; border-radius: 10px;#设置文章背景圆角 margin-top: 60px; background:rgba(颜色rgb,透明度) none repeat scroll !important;&#125; 文章内单行代码样式1234#posts code &#123; color: 颜色代码;#字体颜色 background-color:颜色代码;#背景颜色&#125; 代码块样式修改主题配置文件更改highlight_theme字段12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 文章页面宽度设置1.main-inner &#123;width: 页面宽度;&#125; 文章添加阴影效果1234567.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 网页顶部和底部文字 顶部文字 theme/next/source/css/_common/components/header/site-meta.styl .brand{}中设置color属性 1234567891011&gt; .brand &#123;&gt; position: relative;&gt; display: inline-block;&gt; padding: 0 40px;&gt; // color: $brand-color;&gt; color: #fff !important;&gt; background: $brand-bg;&gt; border-bottom: none;&gt; &amp;:hover &#123; color: $brand-hover-color; &#125;&gt; &#125;&gt; theme/next/source/css/_common/components/header/menu.styl a{}中设置color属性 1234567891011&gt; a &#123;&gt; display: block;&gt; font-size: 13px;&gt; line-height: inherit;&gt; border-bottom: 1px solid $menu-link-border;&gt; transition-property: border-color;&gt; the-transition();&gt; color: #fff !important;&gt; &amp;:hover &#123; border-bottom-color: $menu-link-hover-border; &#125;&gt; &#125;&gt; 底部字体 1.footer-inner &#123;color: 颜色代码;&#125; 文章字体修改文件theme/next/source/css/_common/scaffolding/base.styl 1234567891011body &#123; position: relative; /* Required by scrollspy */ font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: 颜色代码; background: $body-bg-color; +mobile() &#123; padding-right: 0 !important; &#125; +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; Mist风格侧边栏样式侧边栏位置 文件next/source/js/src/motion.js 把所有PaddingRight更改为paddingLeft（有2处） 12&#123;paddingLeft: SIDEBAR_WIDTH&#125;,NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); 文件next/source/css/_common/components/sidebar/sidebar.styl 将.sidebar{}内的right: 0;改为left: 0; 1234.sidebar &#123; position: fixed; left: 0;&#125; 文件next/source/css/_common/components/sidebar/sidebar-toggle.styl 将.sidebar-toggle{}内的right: $b2t-position-right;改为left: $b2t-position-right; 1234.sidebar-toggle &#123; position: fixed; left: $b2t-position-right;&#125; 文件next/source/css/_common/components/back-to-top.styl 将.back-to-top {}内的right: $b2t-position-right;改为left: $b2t-position-right; 123456.back-to-top &#123; box-sizing: border-box; position: fixed; bottom: $b2t-position-bottom; left: $b2t-position-right;&#125; 作者头像旋转文件\\themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 参考博文 http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html https://segmentfault.com/a/1190000009544924#articleHeader21 http://blog.csdn.net/MasterAnt_D/article/details/56839222#t50 https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","categories":[{"name":"前段","slug":"前段","permalink":"http://inagnone.github.io/categories/前段/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://inagnone.github.io/tags/HEXO/"},{"name":"Next","slug":"Next","permalink":"http://inagnone.github.io/tags/Next/"}]},{"title":"activiti笔记","slug":"activiti","date":"2019-06-16T16:22:05.000Z","updated":"2020-12-23T16:31:11.779Z","comments":true,"path":"2019/06/17/activiti/","link":"","permalink":"http://inagnone.github.io/2019/06/17/activiti/","excerpt":"activiti框架学习笔记","text":"activiti框架学习笔记 数据库设计通用数据表（以ACT_GE_开头）存放一些通用数据 资源表（ACT_GE_BYTEARRAY）用于保存于流程引擎相关的资源，资源会被转换为byte数组保存到这个表中。一般情况下，activiti使用这个表来保存字符串、流程文件的内容和流程图片内容 字段 含义 关联表 ID_ 主键 REV_ 数据版本 NAME_ 资源名称 DEPLOYMENT_ID_ 部署ID ACT_RE_DEPLOYMENT_ID BYTES_ 资源内容 GENERATED_ 是否有activiti自动产生的资源 属性表（ACT_GE_PROPERTY） 字段 含义 关联表 NAME_ 属性名称 VALUE_ 属性值 REV_ 数据版本号 初始化时会自动加入4个属性： historyLevel: next.dbid: schema.history: schema.versino: 流程存储表（以ACT_RE_开头）保存流程定义和部署信息 部署数据表（ACT_RE_DEPLOYMENT）对流程部署这一操作的记录 字段 含义 关联表 ID_ 主键 NAME_ 部署名称 DEPLOYMENT_TIME_ 部署时间 流程定义表（ACT_RE_PROCDEF） 字段 说明 关联表 ID_ 主键 REV_ 数据版本 CATEGORY_ 流程定义分类 NAME_ 流程定义的名称，bpmn的xml文件中process元素的name KEY_ 流程定义的key，bpmn的xml文件中process元素的id VERSION 流程定义的版本，流水号，同名流程文件重复部署，版本号+1 DEPLOYMENT_ID 流程定义的对应的部署数ID ACT_RE_DEPLOYMENT RESOURCE_NAME 流程定义对应资源名称，一般问流程文件相对路径 DGRM_RESOURCE_NAME l流程定义对应的流程图的资源名称 HAS_START_FROM_KEY_ 流程文件是否有开始表单 SUSPENSION_STATE_ 流程定义的状态是激活还是终止，激活时为1，终止时为2。如果流程定义终止，将不能启动流程 运行时数据表（以ACT_RU开头）流程实例（执行流）表（ACT_RU_EXECUTION）流程启动后会产生一个流程实例，同时会产生相应的执行流，如果一个流程实例只有一条执行流，那么该表中只产生一条数据，既表示流程实例也表示执行流 字段 说明 关联表 ID_ 主键 REV_ 数据版本 PROC_INST_ID 流程实例id BUSINESS_KEY_ 业务主键 PARENT_ID 流程实例的id。表示当前执行流数据属于哪一个流程实例 ACT_RU_EXECUTION PROC_DEF_ID 流程定义id ACT_RE_PROCDEF SUPER_EXEC 父执行流id。表示当前流程实例属于哪一个执行流 ACT_RU_EXECUTION ACT_ID 当前执行流行为的id IS_ACTIVE 当前执行流是否活跃 IS_CONCURRENT 执行流是否正在并行 IS_SCOPE 是否在执行流范围内 IS_ENEVT_SCOPE 是否在事件范围内 SUSPENSION_STATE 标识流程的中断状态 CACHED_ENT_STATE 流程实例的缓存 流程任务表（ACT_RU_TASK） 字段 说明 关联表 ID_ 主键 REV_ 数据版本 ECECUTION_ID 任务所处执行流id ACT_RU_EXECUTION PROC_INST_ID 对应流程实例id ACT_RU_EXECUTION PROC_DEF_ID 对应流程定义id ACT_RE_PROCDEF NAME_ 任务名称 PARENT_TASK_ID 父任务id ACT_RU_TASK DESCRIPTINO 任务描述 TASK_DEF_KEY 任务定义id，bpmn的xml文件中任务的id OWNER 任务拥有人 ASSIGNEE 任务指派人 DELEGATINO 任务委托状态（等待和已解决） PRIORITY 任务优先级 CREATE_TIME 任务创建时间 DUE_DATE 任务预定日期 流程参数表（ACT_RU_VARIABLE）流程参数类型: 流程实例参数 执行流参数 任务参数 字段 说明 关联表 ID 主键 REV_ 数据版本 TYPE 参数类型，类型有activiti提供 NAME 参数名称 EXECUTION_ID 参数对应执行流id ACT_RU_EXECUTION PROC_INST_ID 参数对应流程实例id ACT_RU_EXECUTION TASK_ID 参数对应任务id ACT_RU_TASK BYTEARRAY_ID 引用资源作为参数值的资源id ACT_GE_BYTEARRAY DOUBLE LONG TEXT TEXT2 历史数据表（以ACT_HI开头）流程实例表 （ACT_HI_PROCINST） 字段 说明 关联表 START_ACT_ID 流程开始的活动的id（开始事件的id） END_ACT_ID 流程结束的活动的id（结束事件的id） DELETE_REASON 流程实例删除原因，如果流程正常结束，该字段为completed 流程明细表（ACT_HI_DETAIL）历史任务表（ACT_HI_TASK）与运行时任务表相似 历史行为表（ACT_HI_ACTINST）记录每一个流程活动的实例，一个流程活动记为一条记录（包括开始事件，结束事件） 字段 说明 关联表 ID 主键 PROC_DEF_ID 流程定义id ACT_RE_PROCDEF PROC_INST_ID 流程实例id EXECUTION_ID 执行流id ACT_ID 流程活动的id（bpmn的xml文件中活动的id） ACT_NAME 流程活动的名称（bpmn的xml文件中活动的name） ACT_TYPE 活动类型 ASSIGNEE 活动指派人 START_TINE 开始时间 END_TIME 结束事件 DURATION 活动持续时间","categories":[{"name":"java","slug":"java","permalink":"http://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"oracle虚拟机规范翻译--java虚拟机结构","slug":"oracle虚拟机规范翻译-java虚拟机结构","date":"2019-05-19T12:48:54.000Z","updated":"2020-12-23T16:31:11.793Z","comments":true,"path":"2019/05/19/oracle虚拟机规范翻译-java虚拟机结构/","link":"","permalink":"http://inagnone.github.io/2019/05/19/oracle虚拟机规范翻译-java虚拟机结构/","excerpt":"oracle虚拟机规范","text":"oracle虚拟机规范 class 文件格式class文件是用来存储经编译器编译过的，与硬件和操作系统独立的二进制代码。class文件精确地定义了一个类或者接口，包括其字节顺序等这些在指定平台被认为是理所当然的细节。 数据类型类似java编程语言，java虚拟机在两种类型上运行：基本类型和引用类型。因此这两种类型的值可以被存储在变量中，作为参数传递，被方法返回或者执行运算。 java虚拟机希望几乎所有的类型检查都在运行之前，有编译器负责而不需要java虚拟机来进行。基本类型的值在运行时不需要被标记或者其他检查来确定它的实际数据类型，也不需要和引用类型的值区分开。取而代之，java","categories":[{"name":"java","slug":"java","permalink":"http://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"类加载器","slug":"类加载器","date":"2019-05-16T16:48:11.000Z","updated":"2020-12-23T16:31:11.914Z","comments":true,"path":"2019/05/17/类加载器/","link":"","permalink":"http://inagnone.github.io/2019/05/17/类加载器/","excerpt":"类加载器学习笔记","text":"类加载器学习笔记 java虚拟机使用类的步奏 java源程序（.java文件）经过编译器编译之后被转换成java字节码文件（.class文件） 类加载器负责读取java字节码文件，并构造出java.lang.Class的一个实例对象。 Class的实例对象调用newInstance()方法创造出该类的一个对象 类加载器的类型 引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。 每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 getClassLoader()方法就可以获取到此引用。 java虚拟机对类的比较Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 类加载器的代理模式类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。","categories":[{"name":"java","slug":"java","permalink":"http://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"分布式框架","slug":"分布式框架","date":"2019-05-02T08:49:22.000Z","updated":"2020-12-23T16:31:11.893Z","comments":true,"path":"2019/05/02/分布式框架/","link":"","permalink":"http://inagnone.github.io/2019/05/02/分布式框架/","excerpt":"分布式框架","text":"分布式框架 HSF ——High Speed Framework 服务提供者 服务调用者 地址服务器 给服务提供者和服务调用者提供部署环境中所有配置服务器和Diamond服务器的服务器列表信息 配置服务器 记录环境内所有服务发布和服务订阅，并将服务相关信息推送到服务节点上。 与所有服务提供者和调用者都是长连接，采用心跳的方式监控服务运行节点的状况 Diamond服务器 通用配置管理服务器，给应用提供统一的配置设置和推送服务 工作原理 服务节点对配置服务器列表的获取。 服务注册发布 服务提供者把自身信息发送到配置服务器 服务的订阅 服务调用者发送调用的服务相关信息到配置服务器，配置服务器返回对应服务的ip和端口等信息 服务规则推送 Diamond服务器对指定服务提供者或调用者推送规则 服务交互","categories":[{"name":"架构","slug":"架构","permalink":"http://inagnone.github.io/categories/架构/"}],"tags":[]},{"title":"java虚拟机结构(一)","slug":"java虚拟机结构-一","date":"2019-04-24T16:00:19.000Z","updated":"2020-12-23T16:31:11.780Z","comments":true,"path":"2019/04/25/java虚拟机结构-一/","link":"","permalink":"http://inagnone.github.io/2019/04/25/java虚拟机结构-一/","excerpt":"java虚拟机学习笔记","text":"java虚拟机学习笔记 Class文件精确定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节上的惯例。 数据类型java虚拟机可以操作的数据类型分给两类： 原始类型 数值类型 整数类型 byte类型：8位有符号 short类型：16位有符号 int类型：32位有符号 long类型：64位有符号 char类型：16位无符号 浮点类型 float类型：32位单精度浮点数 double类型：64位双精度浮点数 boolean类型​ 布尔值true和false，默认false returnAddress类型指向某个操作码的指针，操作码与java虚拟机指令相对应 数据类型 类类型指向动态创建的类实例 数组类型指向动态创建的数组实例 接口类型指向实现了某个接口的类实例 运行时数据区pc寄存器每一个线程都有自己的pc寄存器，且任意时刻都只会各自执行一个方法。如果当前方法时native^native,pc寄存器保存java虚拟机正在执行的字节码指令的地址，如果不是native，pc寄存器保存undefined java虚拟机栈每一个线程都有自己私有的java虚拟机栈，这个栈与线程同时创建，用于存储栈帧 栈异常 stackOverflowError：线程请求分配的栈容量超过了虚拟机允许的最大容量 OutOfmemoryError：扩展栈或者创建一个新线程对应的新栈时，没有足够的内存 栈帧用来存储数据和部分分派结果的数据结构，同时也是用来处理动态链接，方法返回值和异常分派 随方法调用而创建，随方法结束而销毁 栈帧的存储空间由创建它的线程分配在java虚拟机中 每一个栈帧都有自己的本地变量表（局部变量表），操作数栈和指向当前方法所属的类的运行时常量池的引用、 局部变量表 一个局部表量表可以保存一个类型为boolean、byte、char、short、int、float、reference、returnAddress的数据 两个连续的局部变量可以保存一个类型为long或double的数据 局部变量通过索引来进行访问 当调用方法时，参数依次传递到从0开始的连续位置，当调用实例方法时，第0个变量一定是存储该实例方法所在对象的引用(即this关键字) 操作数栈 动态链接 每一个栈帧内部都有一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。在class文件里，一个方法调用其他方法，或者访问成员变量，则需要通过符号引用，动态链接的作用就是就是将这些符号引用所表示的方法转换为对实际方法的直接引用 java堆提供各线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域 堆在虚拟机启动时被创建，存储被gc管理的各种对象 方法区提供各个线程共享的运行时内存区域。 存储一个类的结构信息(运行时常量池，字段，方法数据，构造函数，普通方法的字节码内容) 运行时常量池是class文件中每一个类或者接口的常量池表的运行时表示形式 每一个运行时常量池都在java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池 本地方法栈用来支持native方法执行的栈。(如果虚拟机不支持native方法，可以不提供本地方法栈) 本地方法栈在线程创建的时候按线程分配。","categories":[{"name":"java","slug":"java","permalink":"http://inagnone.github.io/categories/java/"}],"tags":[]},{"title":"位运算--两束之和","slug":"位运算——两数相加","date":"2019-04-18T17:09:47.000Z","updated":"2020-12-23T16:31:11.881Z","comments":true,"path":"2019/04/19/位运算——两数相加/","link":"","permalink":"http://inagnone.github.io/2019/04/19/位运算——两数相加/","excerpt":"leetcode 371题解","text":"leetcode 371题解 371. 两整数之和 两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 例子：11+5 其二进制形式为11: 1011, 5: 0101 计算步骤：1、与运算得出哪些位需要进位11&amp;5 –&gt; 00012、异或运算得到两数二进制各位上分别相加的结果11^5 –&gt; 11103、将需要的进位加到第2步的结果0001表示最后一位需要进位，左移1为0001&lt;&lt;1–》0010此时运算结果为0010与1110的和，重复第一步 123456789public int getSum(int a, int b) &#123; int carry = a &amp; b; int sum = a ^ b; while(carry != 0)&#123; carry = carry &lt;&lt; 1; return getSum(sum,carry); &#125; return sum; &#125; 参考文章：blog.csdn.net/qq508618087/article/details/51789576","categories":[{"name":"leetcode题解","slug":"leetcode题解","permalink":"http://inagnone.github.io/categories/leetcode题解/"}],"tags":[]},{"title":"查询当前数据库中的事务和锁信息","slug":"Mysql事务锁信息","date":"2019-04-18T17:09:47.000Z","updated":"2020-12-23T16:31:11.778Z","comments":true,"path":"2019/04/19/Mysql事务锁信息/","link":"","permalink":"http://inagnone.github.io/2019/04/19/Mysql事务锁信息/","excerpt":"mysql锁查询字段说明","text":"mysql锁查询字段说明 查询当前数据库中的事务和锁信息information_schema.innodb_trx当前运行的所有事务 Field Remark trx_id 事务ID trx_state 事务状态： trx_started 事务开始时间； trx_requested_lock_id innodb_locks.lock_id trx_wait_started 事务开始等待的时间 trx_weight bigint(21) # trx_mysql_thread_id 事务线程ID trx_query 具体SQL语句 trx_operation_state 事务当前操作状态 trx_tables_in_use 事务中有多少个表被使用 trx_tables_locked 事务拥有多少个锁 trx_lock_structs # trx_lock_memory_bytes 事务锁住的内存大小（B） trx_rows_locked 事务锁住的行数 trx_rows_modified 事务更改的行数 trx_concurrency_tickets 事务并发票数 trx_isolation_level 事务隔离级别 trx_unique_checks 是否唯一性检查 trx_foreign_key_checks 是否外键检查 trx_last_foreign_key_error 最后的外键错误 trx_adaptive_hash_latched # trx_adaptive_hash_timeout # information_schema.innodb_locks当前出现的锁 Field Remark lock_id 锁ID lock_trx_id 拥有锁的事务ID lock_mode 锁模式 lock_type 锁类型 lock_table 被锁的表 lock_index 被锁的索引 lock_space 被锁的表空间号 lock_page 被锁的页号 lock_rec 被锁的记录号 lock_data 被锁的数据 innodb_lock_waits.innodb_lock_waits锁等待的对应关系 Field Remark requesting_trx_id 请求锁的事务ID requested_lock_id 请求锁的锁ID blocking_trx_id 当前拥有锁的事务ID blocking_lock_id 当前拥有锁的锁ID show full processlist查询当前数据库中运行的进程信息（相当于正在执行的每一条sql语句的状态信息） Field Remark id 一个标识 user 显示当前用户，如果不是root，这 个命令就只显示你权限范围内的sql语句。 host 显示这个语句是从哪个ip的哪个端口上发出的 db 显示 这个进程目前连接的数据库。 command 显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接 （connect）。 time 此这个状态持续的时间，单位是秒。 state 显示使用当前连接的sql语句的状态，只是语句执行中的某一个状态，一个sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成 info 显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。 state列 Field Remark Checking table 正在检查数据表（这是自动的）。 Closing tables 正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。 Connect Out 复制从服务器正在连接主服务器。 Copying to tmp table on disk 由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。 Creating tmp table 正在创建临时表以存放部分查询结果。 deleting from main table 服务器正在执行多表删除中的第一部分，刚删除第一个表。 deleting from reference tables 服务器正在执行多表删除中的第二部分，正在删除其他表的记录。 Flushing tables 正在执行 FLUSH TABLES，等待其他线程关闭数据表。 Killed 发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志 位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。 Locked 被其他查询锁住了。 Sending data 正在处理 SELECT 查询的记录，同时正在把结果发送给客户端。 Sorting for group 正在为 GROUP BY 做排序。 Sorting for order 正在为 ORDER BY 做排序。 Opening tables 这个过程应该会很快，除非受到其他因素的干扰。例如，在执 ALTER TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。 正尝试打开一个表。 Removing duplicates 正在执行一个 SELECT DISTINCT 方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。 Reopen table 获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。 Repair by sorting 修复指令正在排序以创建索引。 Repair with keycache 修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些。 Searching rows for update 正在讲符合条件的记录找出来以备更新。它必须在 UPDATE 要修改相关的记录之前就完成了。 Sleeping 正在等待客户端发送新请求. System lock 正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加 –skip-external-locking参数来禁止外部系统锁。 Upgrading lock INSERT DELAYED 正在尝试取得一个锁表以插入新记录。 Updating 正在搜索匹配的记录，并且修改它们。 User Lock 正在等待 GET_LOCK()。 Waiting for tables 该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种 情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, 或 OPTIMIZE TABLE。 waiting for handler insert INSERT DELAYED 已经处理完了所有待处理的插入操作，正在等待新的请求。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://inagnone.github.io/categories/数据库/"}],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2019-04-18T17:09:47.000Z","updated":"2020-12-23T16:31:11.792Z","comments":true,"path":"2019/04/19/markdown语法/","link":"","permalink":"http://inagnone.github.io/2019/04/19/markdown语法/","excerpt":"markdown语法学习笔记","text":"markdown语法学习笔记 标题 # This is an H1 ## This is an H2 r 区块引用 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 列表 red green blue 1234567891011* red* green* blue或+ red+ green+ blue、或- red- green- blue red green blue 1231. red2. green3. blue 代码区块分隔线 12345****或- - -或--------------------------- 链接行内式链接这是一个百度 1这是一个[百度](https://www.baidu.com) 参考式链接这是一个百度 12这是一个[百度][1][1]: https://www.baidu.com \"百度地址\" 强调single asterisks single underscores double asterisks double underscores 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 代码行内代码use the print() function 1Use the `printf()` function. 代码区段There is a literal backtick (`) here. 1There is a literal backtick (`) here. 12``There is a literal backtick (`) here.``​```There is a literal backtick (`) here. 1234567891011# 图片![Alt text](https://k.zol-img.com.cn/sjbbs/7692/a7691501_s.jpg&quot;图片&quot;)``` ![Alt text](/path/to/img.jpg &quot;Optional title&quot;)Alt text:图片替代文字“path/to/img.jpg”:图片地址Optional title:图片title ==asd== 删除文本此部分已被删除 1~~~此部分已被删除~~~ 选择框 计划任务 完成任务 12- [x] 计划任务- [] 完成任务 表格 项目 Value 电脑 $1600 手机 $12 导管 $1 12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 设定内容格式使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 123| 第一列 | 第二列 | 第三列 ||:-----------:| -------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 注脚一个具有注脚的文本。^2 123一个具有注脚的文本。[^2][^2]: 注脚的解释 流程图参考","categories":[{"name":"语法","slug":"语法","permalink":"http://inagnone.github.io/categories/语法/"}],"tags":[]}]}