{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"java虚拟机结构(一)","slug":"java虚拟机结构-一","date":"2019-04-24T16:00:19.000Z","updated":"2019-04-29T17:13:03.912Z","comments":true,"path":"2019/04/25/java虚拟机结构-一/","link":"","permalink":"http://yoursite.com/2019/04/25/java虚拟机结构-一/","excerpt":"","text":"Class文件精确定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节上的惯例。 数据类型java虚拟机可以操作的数据类型分给两类： 原始类型 数值类型 整数类型 byte类型：8位有符号 short类型：16位有符号 int类型：32位有符号 long类型：64位有符号 char类型：16位无符号 浮点类型 float类型：32位单精度浮点数 double类型：64位双精度浮点数 boolean类型​ 布尔值true和false，默认false returnAddress类型指向某个操作码的指针，操作码与java虚拟机指令相对应 数据类型 类类型指向动态创建的类实例 数组类型指向动态创建的数组实例 接口类型指向实现了某个接口的类实例 运行时数据区pc寄存器每一个线程都有自己的pc寄存器，且任意时刻都只会各自执行一个方法。如果当前方法时native^native,pc寄存器保存java虚拟机正在执行的字节码指令的地址，如果不是native，pc寄存器保存undefined java虚拟机栈每一个线程都有自己私有的java虚拟机栈，这个栈与线程同时创建，用于存储栈帧 栈异常 stackOverflowError：线程请求分配的栈容量超过了虚拟机允许的最大容量 OutOfmemoryError：扩展栈或者创建一个新线程对应的新栈时，没有足够的内存 栈帧用来存储数据和部分分派结果的数据结构，同时也是用来处理动态链接，方法返回值和异常分派 随方法调用而创建，随方法结束而销毁 栈帧的存储空间由创建它的线程分配在java虚拟机中 每一个栈帧都有自己的本地变量表（局部变量表），操作数栈和指向当前方法所属的类的运行时常量池的引用、 局部变量表 一个局部表量表可以保存一个类型为boolean、byte、char、short、int、float、reference、returnAddress的数据 两个连续的局部变量可以保存一个类型为long或double的数据 局部变量通过索引来进行访问 当调用方法时，参数依次传递到从0开始的连续位置，当调用实例方法时，第0个变量一定是存储该实例方法所在对象的引用(即this关键字) 操作数栈 java堆 提供各线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域 堆在虚拟机启动时被创建，存储被gc管理的各种对象 方法区提供各个线程共享的运行时内存区域。 存储一个类的结构信息(运行时常量池，字段，方法数据，构造函数，普通方法的字节码内容) 运行时常量池是class文件中每一个类或者接口的常量池表的运行时表示形式 每一个运行时常量池都在java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池 本地方法栈用来支持native方法执行的栈。(如果虚拟机不支持native方法，可以不提供本地方法栈) 本地方法栈在线程创建的时候按线程分配。","categories":[],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2019-04-18T17:09:47.000Z","updated":"2019-04-24T15:35:24.241Z","comments":true,"path":"2019/04/19/markdown语法/","link":"","permalink":"http://yoursite.com/2019/04/19/markdown语法/","excerpt":"","text":"标题 # This is an H1 ## This is an H2 r 区块引用 This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. 列表 red green blue 1234567891011* red* green* blue或+ red+ green+ blue、或- red- green- blue red green blue 1231. red2. green3. blue 代码区块分隔线 12345****或- - -或--------------------------- 链接行内式链接这是一个百度 1这是一个[百度](https://www.baidu.com) 参考式链接这是一个百度 12这是一个[百度][1][1]: https://www.baidu.com \"百度地址\" 强调single asterisks single underscores double asterisks double underscores 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 代码行内代码use the print() function 1Use the `printf()` function. 代码区段There is a literal backtick (`) here. 1There is a literal backtick (`) here. 12``There is a literal backtick (`) here.``​```There is a literal backtick (`) here. 1234567891011# 图片![Alt text](https://k.zol-img.com.cn/sjbbs/7692/a7691501_s.jpg&quot;图片&quot;)``` ![Alt text](/path/to/img.jpg &quot;Optional title&quot;)Alt text:图片替代文字“path/to/img.jpg”:图片地址Optional title:图片title ==asd== 删除文本此部分已被删除 1~~~此部分已被删除~~~ 选择框 计划任务 完成任务 12- [x] 计划任务- [] 完成任务 表格 项目 Value 电脑 $1600 手机 $12 导管 $1 12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 设定内容格式使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 123| 第一列 | 第二列 | 第三列 ||:-----------:| -------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 注脚一个具有注脚的文本。^2 123一个具有注脚的文本。[^2][^2]: 注脚的解释 流程图参考","categories":[],"tags":[]},{"title":"位运算--两束之和","slug":"位运算——两数相加","date":"2019-04-18T17:09:47.000Z","updated":"2019-04-24T15:34:53.179Z","comments":true,"path":"2019/04/19/位运算——两数相加/","link":"","permalink":"http://yoursite.com/2019/04/19/位运算——两数相加/","excerpt":"","text":"371. 两整数之和 两位单独的位相加其结果可以用异或得到, 进位可以用与得到. 例子：11+5 其二进制形式为11: 1011, 5: 0101 计算步骤：1、与运算得出哪些位需要进位11&amp;5 –&gt; 00012、异或运算得到两数二进制各位上分别相加的结果11^5 –&gt; 11103、将需要的进位加到第2步的结果0001表示最后一位需要进位，左移1为0001&lt;&lt;1–》0010此时运算结果为0010与1110的和，重复第一步 123456789public int getSum(int a, int b) &#123; int carry = a &amp; b; int sum = a ^ b; while(carry != 0)&#123; carry = carry &lt;&lt; 1; return getSum(sum,carry); &#125; return sum; &#125; 参考文章：blog.csdn.net/qq508618087/article/details/51789576","categories":[],"tags":[]},{"title":"查询当前数据库中的事务和锁信息","slug":"Mysql事务锁信息","date":"2019-04-18T17:09:47.000Z","updated":"2019-04-24T15:52:33.824Z","comments":true,"path":"2019/04/19/Mysql事务锁信息/","link":"","permalink":"http://yoursite.com/2019/04/19/Mysql事务锁信息/","excerpt":"","text":"查询当前数据库中的事务和锁信息information_schema.innodb_trx当前运行的所有事务Field | Remark———— | ——– |trx_id | 事务IDtrx_state | 事务状态：trx_started | 事务开始时间；trx_requested_lock_id |innodb_locks.lock_idtrx_wait_started |事务开始等待的时间trx_weight bigint(21) | #trx_mysql_thread_id | 事务线程IDtrx_query | 具体SQL语句trx_operation_state | 事务当前操作状态trx_tables_in_use | 事务中有多少个表被使用trx_tables_locked | 事务拥有多少个锁trx_lock_structs | #trx_lock_memory_bytes | 事务锁住的内存大小（B）trx_rows_locked | 事务锁住的行数trx_rows_modified | 事务更改的行数trx_concurrency_tickets | 事务并发票数trx_isolation_level | 事务隔离级别trx_unique_checks | 是否唯一性检查trx_foreign_key_checks | 是否外键检查trx_last_foreign_key_error | 最后的外键错误trx_adaptive_hash_latched | #trx_adaptive_hash_timeout | # information_schema.innodb_locks当前出现的锁Field | Remark————– | ——– |lock_id | 锁ID |lock_trx_id |拥有锁的事务IDlock_mode | 锁模式lock_type |锁类型lock_table |被锁的表lock_index | 被锁的索引lock_space | 被锁的表空间号lock_page | 被锁的页号lock_rec | 被锁的记录号lock_data | 被锁的数据 innodb_lock_waits.innodb_lock_waits锁等待的对应关系Field | Remark————– | ——– |requesting_trx_id | 请求锁的事务IDrequested_lock_id | 请求锁的锁IDblocking_trx_id | 当前拥有锁的事务IDblocking_lock_id | 当前拥有锁的锁ID show full processlist查询当前数据库中运行的进程信息（相当于正在执行的每一条sql语句的状态信息）Field | Remark————– | ——– |id | 一个标识user| 显示当前用户，如果不是root，这 个命令就只显示你权限范围内的sql语句。host| 显示这个语句是从哪个ip的哪个端口上发出的db|显示 这个进程目前连接的数据库。command|显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接 （connect）。time| 此这个状态持续的时间，单位是秒。state|显示使用当前连接的sql语句的状态，只是语句执行中的某一个状态，一个sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成info| 显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。 state列 Field Remark Checking table 正在检查数据表（这是自动的）。 Closing tables 正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。 Connect Out 复制从服务器正在连接主服务器。 Copying to tmp table on disk 由于临时结果集大于 tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。 Creating tmp table 正在创建临时表以存放部分查询结果。 deleting from main table 服务器正在执行多表删除中的第一部分，刚删除第一个表。 deleting from reference tables 服务器正在执行多表删除中的第二部分，正在删除其他表的记录。 Flushing tables 正在执行 FLUSH TABLES，等待其他线程关闭数据表。 Killed 发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志 位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。 Locked 被其他查询锁住了。 Sending data 正在处理 SELECT 查询的记录，同时正在把结果发送给客户端。 Sorting for group 正在为 GROUP BY 做排序。 Sorting for order 正在为 ORDER BY 做排序。 Opening tables 这个过程应该会很快，除非受到其他因素的干扰。例如，在执 ALTER TABLE 或 LOCK TABLE 语句行完以前，数据表无法被其他线程打开。 正尝试打开一个表。 Removing duplicates 正在执行一个 SELECT DISTINCT 方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。 Reopen table 获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。 Repair by sorting 修复指令正在排序以创建索引。 Repair with keycache 修复指令正在利用索引缓存一个一个地创建新索引。它会比 Repair by sorting 慢些。 Searching rows for update 正在讲符合条件的记录找出来以备更新。它必须在 UPDATE 要修改相关的记录之前就完成了。 Sleeping 正在等待客户端发送新请求. System lock 正在等待取得一个外部的系统锁。如果当前没有运行多个 mysqld 服务器同时请求同一个表，那么可以通过增加 –skip-external-locking参数来禁止外部系统锁。 Upgrading lock INSERT DELAYED 正在尝试取得一个锁表以插入新记录。 Updating 正在搜索匹配的记录，并且修改它们。 User Lock 正在等待 GET_LOCK()。 Waiting for tables 该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种 情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE, 或 OPTIMIZE TABLE。 waiting for handler insert INSERT DELAYED 已经处理完了所有待处理的插入操作，正在等待新的请求。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-18T16:57:04.981Z","updated":"2019-04-18T16:57:04.981Z","comments":true,"path":"2019/04/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}